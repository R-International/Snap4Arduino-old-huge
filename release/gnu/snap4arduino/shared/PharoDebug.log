THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "analogPins" is nil
17 January 2014 1:39:33.364 pm

VM: unix - i686 - linux-gnu - CoInterpreter * VMMaker-oscog-EstebanLorenzano.303 uuid: 2facc2ec-9943-43f4-b0cd-9504c874df9d Oct 17 2013
StackToRegisterMappingCogit * VMMaker-oscog-EstebanLorenzano.303 uuid: 2facc2ec-9943-43f4-b0cd-9504c874df9d Oct 17 2013
git://gitorious.org/cogvm/blessed.git Commit: 3d9341c3ef68118f438ff649b343d2fe77952477 Date: 2013-08-08 16:13:25 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> 

Image: Pharo2.0 [Latest update: #20624]

UndefinedObject(Object)>>doesNotUnderstand: #analogPins
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	analogPins
		exception: 	MessageNotUnderstood: receiver of "analogPins" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

S4ArduinoManager>>analogReadings
	Receiver: a S4ArduinoManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		board: 	nil
		digitalPinModeDictionary: 	a Dictionary(#I->InputMode #O->OutputMode #P->PwmMode...etc...
		analogPinModeDictionary: 	nil


S4ACommandHandler>>analogReadings
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
a S4ACommandHandler

S4ACommandHandler>>handle:
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 
		aCommand: 	#(#analogReadings)
		commandName: 	#analogReadings
		arguments: 	#()
	Receiver's instance variables: 
a S4ACommandHandler

S4AWebSocketHandler>>handleMessage:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aMessage: 	'analogReadings'
		parsedMessage: 	#(#analogReadings)
		response: 	nil
	Receiver's instance variables: 
a S4AWebSocketHandler

[:message | 
| response |
self debugLog: 'Received WebSocket message from Snap!: ' , message.
	response := self handleMessage: message.
	response
		ifNotNil: [aWebSocket sendText: response asString.
			self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]] in [aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aWebSocket: 	a ZnWebSocket(#server)
		message: 	'analogReadings'
		response: 	nil
	Receiver's instance variables: 
a S4AWebSocketHandler

ZnWebSocket>>runWith:
	Receiver: a ZnWebSocket(#server)
	Arguments and temporary variables: 
		block: 	[:message | 
| response |
self debugLog: 'Received WebSocket message fro...etc...
		message: 	'analogReadings'
	Receiver's instance variables: 
		stream: 	a ZdcSocketStream
		role: 	#server
		log: 	a ZnLogSupport


[aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aWebSocket: 	a ZnWebSocket(#server)
	Receiver's instance variables: 
a S4AWebSocketHandler

BlockClosure>>on:do:
	Receiver: [aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket ...etc...
	Arguments and temporary variables: 
		exception: 	ConnectionClosed
		handlerAction: 	[self debugLog: 'WebSocket connection closed']
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	S4AWebSocketHandler>>value:
		startpc: 	70
		numArgs: 	0


S4AWebSocketHandler>>value:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aWebSocket: 	a ZnWebSocket(#server)
	Receiver's instance variables: 
a S4AWebSocketHandler

[:webSocket | 
webSocket log: self log.
	self handler value: webSocket] in ZnWebSocketDelegate>>continuation
	Receiver: a ZnWebSocketDelegate
	Arguments and temporary variables: 
		webSocket: 	a ZnWebSocket(#server)
	Receiver's instance variables: 
		prefix: 	an OrderedCollection('s4a')
		handler: 	a S4AWebSocketHandler


ZnWebSocketResponse>>useConnection:
	Receiver: a ZnWebSocketResponse(101 Switching Protocols)
	Arguments and temporary variables: 
		connection: 	a ZdcSocketStream
		webSocket: 	a ZnWebSocket(#server)
		message: 	nil
	Receiver's instance variables: 
		headers: 	a ZnHeaders('Connection'->'Upgrade' 'Date'->'Fri, 17 Jan 2014 12:35:50...etc...
		entity: 	nil
		statusLine: 	a ZnStatusLine(101 Switching Protocols)
		continuation: 	[:webSocket | 
webSocket log: self log.
	self handler value: webS...etc...


ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		stream: 	a ZdcSocketStream
		request: 	a ZnRequest(GET /s4a)
		response: 	a ZnWebSocketResponse(101 Switching Protocols)
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[[self executeOneRequestResponseOn: stream] whileFalse.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		stream: 	a ZdcSocketStream
		request: 	nil
		response: 	nil
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[p psValueAt: index put: anObject.
	aBlock value] in ZnCurrentServer(DynamicVariable)>>value:during:
	Receiver: a ZnCurrentServer
	Arguments and temporary variables: 
		anObject: 	a ZnManagingMultiThreadedServer(running 4001)
		aBlock: 	[[self executeOneRequestResponseOn: stream] whileFalse.
	nil]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	5


BlockClosure>>ensure:
	Receiver: [p psValueAt: index put: anObject.
	aBlock value]
	Arguments and temporary variables: 
		aBlock: 	[p psValueAt: index put: oldValue]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnCurrentServer(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnCurrentServer(DynamicVariable)>>value:during:
	Receiver: a ZnCurrentServer
	Arguments and temporary variables: 
		anObject: 	a ZnManagingMultiThreadedServer(running 4001)
		aBlock: 	[[self executeOneRequestResponseOn: stream] whileFalse.
	nil]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	5


ZnCurrentServer class(DynamicVariable class)>>value:during:
	Receiver: ZnCurrentServer
	Arguments and temporary variables: 
		anObject: 	a ZnManagingMultiThreadedServer(running 4001)
		aBlock: 	[[self executeOneRequestResponseOn: stream] whileFalse.
	nil]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	132
		layout: 	nil
		instanceVariables: 	nil
		organization: 	a ClassOrganizer
		subclasses: 	nil
		name: 	#ZnCurrentServer
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	nil
		localSelectors: 	nil
		hash: 	nil
		soleInstance: 	a ZnCurrentServer


ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		stream: 	a ZdcSocketStream
		request: 	nil
		response: 	nil
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[self executeRequestResponseLoopOn: stream] in [[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		listeningSocket: 	a Socket[waitingForConnection]
		stream: 	a ZdcSocketStream
		socket: 	a Socket[connected]
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


BlockClosure>>ensure:
	Receiver: [self executeRequestResponseLoopOn: stream]
	Arguments and temporary variables: 
		aBlock: 	[self log debug: 'Closing stream'.
	self closeSocketStream: stream]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[[self executeRequestResponseLoopOn: stream]
		ensure: [self log ...etc...
		startpc: 	118
		numArgs: 	0


[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		listeningSocket: 	a Socket[waitingForConnection]
		stream: 	a ZdcSocketStream
		socket: 	a Socket[connected]
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


BlockClosure>>ifCurtailed:
	Receiver: [[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
...etc...
	Arguments and temporary variables: 
		aBlock: 	[self log debug: 'Destroying socket'.
	socket destroy]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	[[[self executeRequestResponseLoopOn: stream]
		ensure: [self log...etc...
		startpc: 	113
		numArgs: 	0


[[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		listeningSocket: 	a Socket[waitingForConnection]
		stream: 	a ZdcSocketStream
		socket: 	a Socket[connected]
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[self value.
	Processor terminateActive] in BlockClosure>>newProcess
	Receiver: [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'....etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnec...etc...
		startpc: 	108
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #analogPins
S4ArduinoManager>>analogReadings
S4ACommandHandler>>analogReadings
S4ACommandHandler>>handle:
S4AWebSocketHandler>>handleMessage:
[:message | 
| response |
self debugLog: 'Received WebSocket message from Snap!: ' , message.
	response := self handleMessage: message.
	response
		ifNotNil: [aWebSocket sendText: response asString.
			self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]] in [aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
ZnWebSocket>>runWith:
[aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
BlockClosure>>on:do:
S4AWebSocketHandler>>value:
[:webSocket | 
webSocket log: self log.
	self handler value: webSocket] in ZnWebSocketDelegate>>continuation
ZnWebSocketResponse>>useConnection:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[[self executeOneRequestResponseOn: stream] whileFalse.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[p psValueAt: index put: anObject.
	aBlock value] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[self executeRequestResponseLoopOn: stream] in [[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
BlockClosure>>ifCurtailed:
Delay>>wait
WorldState>>interCyclePause:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in MorphicUIManager>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[self runTimerEventLoop] in Delay class>>startTimerEventLoop
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[self eventLoop] in InputEventFetcher>>installEventLoop
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[self lowSpaceWatcher] in SmalltalkImage>>installLowSpaceWatcher
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in ProcessorScheduler class>>idleProcess
  stack:

ProcessorScheduler class>>idleProcess
[self idleProcess] in ProcessorScheduler class>>startUp
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [[event wait.
	processSynchronizationDelay wait.
	self changed: #childProcessStatus] repeat.
	nil] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[[event wait.
	processSynchronizationDelay wait.
	self changed: #childProcessStatus] repeat.
	nil] in UnixOSProcessAccessor>>grimReaperProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>waitForAcceptFor:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[[serverSocket isValid
		ifFalse: [^ self listenLoop].
	self serveConnectionsOn: serverSocket] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
BlockClosure>>ifCurtailed:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
[[self listenLoop] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>start
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>waitForAcceptFor:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[[serverSocket isValid
		ifFalse: [^ self listenLoop].
	self serveConnectionsOn: serverSocket] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
BlockClosure>>ifCurtailed:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
[[self listenLoop] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>start
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
logger nextPutAll: 'Processes and their stacks: ';
		 cr.
	Process allInstances
		do: [:each | 
			| ctx |
			logger nextPutAll: 'Process: ';
				 print: each;
				 cr;
				 nextPutAll: '  stack:';
				 cr;
				 cr.
			ctx := each isActiveProcess
						ifTrue: [thisContext sender]
						ifFalse: [each suspendedContext].
			ctx
				ifNotNil: [(ctx stackOfSize: 20)
						do: [:s | logger print: s;
								 cr]].
			logger nextPutAll: '------------------------------';
				 cr;
				 cr]] in [Smalltalk logError: aString inContext: aContext.
	Smalltalk
		logDuring: [:logger | 
			logger nextPutAll: 'Processes and their stacks: ';
				 cr.
			Process allInstances
				do: [:each | 
					| ctx |
					logger nextPutAll: 'Process: ';
						 print: each;
						 cr;
						 nextPutAll: '  stack:';
						 cr;
						 cr.
					ctx := each isActiveProcess
								ifTrue: [thisContext sender]
								ifFalse: [each suspendedContext].
					ctx
						ifNotNil: [(ctx stackOfSize: 20)
								do: [:s | logger print: s;
										 cr]].
					logger nextPutAll: '------------------------------';
						 cr;
						 cr]]] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[logStream := self openLog.
	aMonadicBlock value: logStream] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[Smalltalk logError: aString inContext: aContext.
	Smalltalk
		logDuring: [:logger | 
			logger nextPutAll: 'Processes and their stacks: ';
				 cr.
			Process allInstances
				do: [:each | 
					| ctx |
					logger nextPutAll: 'Process: ';
						 print: each;
						 cr;
						 nextPutAll: '  stack:';
						 cr;
						 cr.
					ctx := each isActiveProcess
								ifTrue: [thisContext sender]
								ifFalse: [each suspendedContext].
					ctx
						ifNotNil: [(ctx stackOfSize: 20)
								do: [:s | logger print: s;
										 cr]].
					logger nextPutAll: '------------------------------';
						 cr;
						 cr]]] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MessageNotUnderstood(Error)>>defaultAction
MessageNotUnderstood>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
MessageNotUnderstood(Exception)>>signal
UndefinedObject(Object)>>doesNotUnderstand: #analogPins
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [ScheduledDelay := self.
	TimingSemaphore signal] in Delay>>schedule
  stack:

[ScheduledDelay := self.
	TimingSemaphore signal] in Delay>>schedule
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
Delay>>schedule
Delay>>wait
[[self step.
	(Delay forMilliseconds: self stepTime) wait] repeat.
	nil] in Firmata>>startSteppingProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in HashTableSizes class>>atLeast:
  stack:

HashTableSizes class>>atLeast:
Set class>>sizeFor:
Set class(HashedCollection class)>>new:
RxMatchOptimizer>>initialize:ignoreCase:
RxMatcher>>initialize:ignoreCase:
RxMatcher class>>for:ignoreCase:
RxMatcher class>>for:
ByteString(String)>>asRegex
ByteString(String)>>matchesRegex:
[:each | each name matchesRegex: '.*Firmata.*|.*Arduino.*'] in S4AServer class>>terminateArduinoProcesses
Array(SequenceableCollection)>>select:
S4AServer class>>terminateArduinoProcesses
S4ArduinoManager>>disconnect
[(Delay forMilliseconds: 100) wait.
	S4ArduinoManager singleton disconnect] in [[[self sendKeepAlive]
		on: Error
		do: [(Delay forMilliseconds: 100) wait.
			S4ArduinoManager singleton disconnect].
	(Delay forMilliseconds: self keepAliveTime) wait] repeat.
	nil] in Arduino>>startKeepAliveProcess
BlockClosure>>cull:
[self exceptionHandlerBlock cull: exception] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
PrimitiveFailed(Exception)>>signal
PrimitiveFailed class(SelectorException class)>>signalFor:
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

THERE_BE_DRAGONS_HERE
Error: incorrect number of arguments
17 January 2014 1:40:19.614 pm

VM: unix - i686 - linux-gnu - CoInterpreter * VMMaker-oscog-EstebanLorenzano.303 uuid: 2facc2ec-9943-43f4-b0cd-9504c874df9d Oct 17 2013
StackToRegisterMappingCogit * VMMaker-oscog-EstebanLorenzano.303 uuid: 2facc2ec-9943-43f4-b0cd-9504c874df9d Oct 17 2013
git://gitorious.org/cogvm/blessed.git Commit: 3d9341c3ef68118f438ff649b343d2fe77952477 Date: 2013-08-08 16:13:25 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> 

Image: Pharo2.0 [Latest update: #20624]

S4ACommandHandler(Object)>>error:
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 
		aString: 	'incorrect number of arguments'
	Receiver's instance variables: 
a S4ACommandHandler

S4ACommandHandler(Object)>>perform:withArguments:inSuperclass:
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 
		selector: 	#activateAnalogPinNumber:
		argArray: 	#()
		lookupClass: 	S4ACommandHandler
	Receiver's instance variables: 
a S4ACommandHandler

S4ACommandHandler(Object)>>perform:withArguments:
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 
		selector: 	#activateAnalogPinNumber:
		argArray: 	#()
	Receiver's instance variables: 
a S4ACommandHandler

S4ACommandHandler>>handle:
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 
		aCommand: 	#(#activateAnalogPin)
		commandName: 	#activateAnalogPin
		arguments: 	#()
	Receiver's instance variables: 
a S4ACommandHandler

S4AWebSocketHandler>>handleMessage:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aMessage: 	'activateAnalogPin&'
		parsedMessage: 	#(#activateAnalogPin)
		response: 	nil
	Receiver's instance variables: 
a S4AWebSocketHandler

[:message | 
| response |
self debugLog: 'Received WebSocket message from Snap!: ' , message.
	response := self handleMessage: message.
	response
		ifNotNil: [aWebSocket sendText: response asString.
			self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]] in [aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aWebSocket: 	a ZnWebSocket(#server)
		message: 	'activateAnalogPin&'
		response: 	nil
	Receiver's instance variables: 
a S4AWebSocketHandler

ZnWebSocket>>runWith:
	Receiver: a ZnWebSocket(#server)
	Arguments and temporary variables: 
		block: 	[:message | 
| response |
self debugLog: 'Received WebSocket message fro...etc...
		message: 	'activateAnalogPin&'
	Receiver's instance variables: 
		stream: 	a ZdcSocketStream
		role: 	#server
		log: 	a ZnLogSupport


[aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aWebSocket: 	a ZnWebSocket(#server)
	Receiver's instance variables: 
a S4AWebSocketHandler

BlockClosure>>on:do:
	Receiver: [aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket ...etc...
	Arguments and temporary variables: 
		exception: 	ConnectionClosed
		handlerAction: 	[self debugLog: 'WebSocket connection closed']
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	S4AWebSocketHandler>>value:
		startpc: 	70
		numArgs: 	0


S4AWebSocketHandler>>value:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aWebSocket: 	a ZnWebSocket(#server)
	Receiver's instance variables: 
a S4AWebSocketHandler

[:webSocket | 
webSocket log: self log.
	self handler value: webSocket] in ZnWebSocketDelegate>>continuation
	Receiver: a ZnWebSocketDelegate
	Arguments and temporary variables: 
		webSocket: 	a ZnWebSocket(#server)
	Receiver's instance variables: 
		prefix: 	an OrderedCollection('s4a')
		handler: 	a S4AWebSocketHandler


ZnWebSocketResponse>>useConnection:
	Receiver: a ZnWebSocketResponse(101 Switching Protocols)
	Arguments and temporary variables: 
		connection: 	a ZdcSocketStream
		webSocket: 	a ZnWebSocket(#server)
		message: 	nil
	Receiver's instance variables: 
		headers: 	a ZnHeaders('Connection'->'Upgrade' 'Date'->'Fri, 17 Jan 2014 12:39:48...etc...
		entity: 	nil
		statusLine: 	a ZnStatusLine(101 Switching Protocols)
		continuation: 	[:webSocket | 
webSocket log: self log.
	self handler value: webS...etc...


ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		stream: 	a ZdcSocketStream
		request: 	a ZnRequest(GET /s4a)
		response: 	a ZnWebSocketResponse(101 Switching Protocols)
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[[self executeOneRequestResponseOn: stream] whileFalse.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		stream: 	a ZdcSocketStream
		request: 	nil
		response: 	nil
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[p psValueAt: index put: anObject.
	aBlock value] in ZnCurrentServer(DynamicVariable)>>value:during:
	Receiver: a ZnCurrentServer
	Arguments and temporary variables: 
		anObject: 	a ZnManagingMultiThreadedServer(running 4001)
		aBlock: 	[[self executeOneRequestResponseOn: stream] whileFalse.
	nil]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	5


BlockClosure>>ensure:
	Receiver: [p psValueAt: index put: anObject.
	aBlock value]
	Arguments and temporary variables: 
		aBlock: 	[p psValueAt: index put: oldValue]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnCurrentServer(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnCurrentServer(DynamicVariable)>>value:during:
	Receiver: a ZnCurrentServer
	Arguments and temporary variables: 
		anObject: 	a ZnManagingMultiThreadedServer(running 4001)
		aBlock: 	[[self executeOneRequestResponseOn: stream] whileFalse.
	nil]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	5


ZnCurrentServer class(DynamicVariable class)>>value:during:
	Receiver: ZnCurrentServer
	Arguments and temporary variables: 
		anObject: 	a ZnManagingMultiThreadedServer(running 4001)
		aBlock: 	[[self executeOneRequestResponseOn: stream] whileFalse.
	nil]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	132
		layout: 	nil
		instanceVariables: 	nil
		organization: 	a ClassOrganizer
		subclasses: 	nil
		name: 	#ZnCurrentServer
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	nil
		localSelectors: 	nil
		hash: 	nil
		soleInstance: 	a ZnCurrentServer


ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		stream: 	a ZdcSocketStream
		request: 	nil
		response: 	nil
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[self executeRequestResponseLoopOn: stream] in [[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		listeningSocket: 	a Socket[waitingForConnection]
		stream: 	a ZdcSocketStream
		socket: 	a Socket[connected]
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


BlockClosure>>ensure:
	Receiver: [self executeRequestResponseLoopOn: stream]
	Arguments and temporary variables: 
		aBlock: 	[self log debug: 'Closing stream'.
	self closeSocketStream: stream]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[[self executeRequestResponseLoopOn: stream]
		ensure: [self log ...etc...
		startpc: 	118
		numArgs: 	0


[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		listeningSocket: 	a Socket[waitingForConnection]
		stream: 	a ZdcSocketStream
		socket: 	a Socket[connected]
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


BlockClosure>>ifCurtailed:
	Receiver: [[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
...etc...
	Arguments and temporary variables: 
		aBlock: 	[self log debug: 'Destroying socket'.
	socket destroy]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	[[[self executeRequestResponseLoopOn: stream]
		ensure: [self log...etc...
		startpc: 	113
		numArgs: 	0


[[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		listeningSocket: 	a Socket[waitingForConnection]
		stream: 	a ZdcSocketStream
		socket: 	a Socket[connected]
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[self value.
	Processor terminateActive] in BlockClosure>>newProcess
	Receiver: [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'....etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnec...etc...
		startpc: 	108
		numArgs: 	0



--- The full stack ---
S4ACommandHandler(Object)>>error:
S4ACommandHandler(Object)>>perform:withArguments:inSuperclass:
S4ACommandHandler(Object)>>perform:withArguments:
S4ACommandHandler>>handle:
S4AWebSocketHandler>>handleMessage:
[:message | 
| response |
self debugLog: 'Received WebSocket message from Snap!: ' , message.
	response := self handleMessage: message.
	response
		ifNotNil: [aWebSocket sendText: response asString.
			self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]] in [aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
ZnWebSocket>>runWith:
[aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
BlockClosure>>on:do:
S4AWebSocketHandler>>value:
[:webSocket | 
webSocket log: self log.
	self handler value: webSocket] in ZnWebSocketDelegate>>continuation
ZnWebSocketResponse>>useConnection:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[[self executeOneRequestResponseOn: stream] whileFalse.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[p psValueAt: index put: anObject.
	aBlock value] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[self executeRequestResponseLoopOn: stream] in [[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
BlockClosure>>ifCurtailed:
Delay>>wait
WorldState>>interCyclePause:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in MorphicUIManager>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[self runTimerEventLoop] in Delay class>>startTimerEventLoop
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[self eventLoop] in InputEventFetcher>>installEventLoop
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[self lowSpaceWatcher] in SmalltalkImage>>installLowSpaceWatcher
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in ProcessorScheduler class>>idleProcess
  stack:

ProcessorScheduler class>>idleProcess
[self idleProcess] in ProcessorScheduler class>>startUp
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [[event wait.
	processSynchronizationDelay wait.
	self changed: #childProcessStatus] repeat.
	nil] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[[event wait.
	processSynchronizationDelay wait.
	self changed: #childProcessStatus] repeat.
	nil] in UnixOSProcessAccessor>>grimReaperProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>waitForAcceptFor:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[[serverSocket isValid
		ifFalse: [^ self listenLoop].
	self serveConnectionsOn: serverSocket] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
BlockClosure>>ifCurtailed:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
[[self listenLoop] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>start
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>waitForAcceptFor:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[[serverSocket isValid
		ifFalse: [^ self listenLoop].
	self serveConnectionsOn: serverSocket] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
BlockClosure>>ifCurtailed:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
[[self listenLoop] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>start
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForDataFor:ifClosed:ifTimedOut:
Socket>>waitForDataFor:
ZdcSocketStream(ZdcAbstractSocketStream)>>socketWaitForData
ZdcSocketStream(ZdcSimpleSocketStream)>>fillReadBuffer
ZdcSocketStream(ZdcAbstractSocketStream)>>next
ZnLineReader>>processNext
ZnLineReader>>nextLine
ZnRequestLine>>readFrom:
ZnRequestLine class>>readFrom:
ZnRequest>>readHeaderFrom:
ZnRequest(ZnMessage)>>readFrom:
ZnRequest class(ZnMessage class)>>readFrom:
[:stream | ZnRequest readFrom: stream] in [[:stream | ZnRequest readFrom: stream]] in ZnManagingMultiThreadedServer(ZnServer)>>reader
[self reader value: stream] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>readRequest:
[^ block value] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>withMaximumEntitySizeDo:
[p psValueAt: index put: anObject.
	aBlock value] in ZnMaximumEntitySize(DynamicVariable)>>value:during:
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
logger nextPutAll: 'Processes and their stacks: ';
		 cr.
	Process allInstances
		do: [:each | 
			| ctx |
			logger nextPutAll: 'Process: ';
				 print: each;
				 cr;
				 nextPutAll: '  stack:';
				 cr;
				 cr.
			ctx := each isActiveProcess
						ifTrue: [thisContext sender]
						ifFalse: [each suspendedContext].
			ctx
				ifNotNil: [(ctx stackOfSize: 20)
						do: [:s | logger print: s;
								 cr]].
			logger nextPutAll: '------------------------------';
				 cr;
				 cr]] in [Smalltalk logError: aString inContext: aContext.
	Smalltalk
		logDuring: [:logger | 
			logger nextPutAll: 'Processes and their stacks: ';
				 cr.
			Process allInstances
				do: [:each | 
					| ctx |
					logger nextPutAll: 'Process: ';
						 print: each;
						 cr;
						 nextPutAll: '  stack:';
						 cr;
						 cr.
					ctx := each isActiveProcess
								ifTrue: [thisContext sender]
								ifFalse: [each suspendedContext].
					ctx
						ifNotNil: [(ctx stackOfSize: 20)
								do: [:s | logger print: s;
										 cr]].
					logger nextPutAll: '------------------------------';
						 cr;
						 cr]]] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[logStream := self openLog.
	aMonadicBlock value: logStream] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[Smalltalk logError: aString inContext: aContext.
	Smalltalk
		logDuring: [:logger | 
			logger nextPutAll: 'Processes and their stacks: ';
				 cr.
			Process allInstances
				do: [:each | 
					| ctx |
					logger nextPutAll: 'Process: ';
						 print: each;
						 cr;
						 nextPutAll: '  stack:';
						 cr;
						 cr.
					ctx := each isActiveProcess
								ifTrue: [thisContext sender]
								ifFalse: [each suspendedContext].
					ctx
						ifNotNil: [(ctx stackOfSize: 20)
								do: [:s | logger print: s;
										 cr]].
					logger nextPutAll: '------------------------------';
						 cr;
						 cr]]] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
Error>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
Error(Exception)>>signal
Error(Exception)>>signal:
S4ACommandHandler(Object)>>error:
------------------------------

Process: a Process in [ScheduledDelay := self.
	TimingSemaphore signal] in Delay>>schedule
  stack:

[ScheduledDelay := self.
	TimingSemaphore signal] in Delay>>schedule
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
Delay>>schedule
Delay>>wait
[[self step.
	(Delay forMilliseconds: self stepTime) wait] repeat.
	nil] in Firmata>>startSteppingProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
BlockClosure>>ifCurtailed:
Delay>>wait
[[[self sendKeepAlive]
		on: Error
		do: [(Delay forMilliseconds: 100) wait.
			S4ArduinoManager singleton disconnect].
	(Delay forMilliseconds: self keepAliveTime) wait] repeat.
	nil] in Arduino>>startKeepAliveProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

THERE_BE_DRAGONS_HERE
Error: incorrect number of arguments
17 January 2014 1:41:21.918 pm

VM: unix - i686 - linux-gnu - CoInterpreter * VMMaker-oscog-EstebanLorenzano.303 uuid: 2facc2ec-9943-43f4-b0cd-9504c874df9d Oct 17 2013
StackToRegisterMappingCogit * VMMaker-oscog-EstebanLorenzano.303 uuid: 2facc2ec-9943-43f4-b0cd-9504c874df9d Oct 17 2013
git://gitorious.org/cogvm/blessed.git Commit: 3d9341c3ef68118f438ff649b343d2fe77952477 Date: 2013-08-08 16:13:25 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> 

Image: Pharo2.0 [Latest update: #20624]

S4ACommandHandler(Object)>>error:
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 
		aString: 	'incorrect number of arguments'
	Receiver's instance variables: 
a S4ACommandHandler

S4ACommandHandler(Object)>>perform:withArguments:inSuperclass:
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 
		selector: 	#activateAnalogPinNumber:
		argArray: 	#()
		lookupClass: 	S4ACommandHandler
	Receiver's instance variables: 
a S4ACommandHandler

S4ACommandHandler(Object)>>perform:withArguments:
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 
		selector: 	#activateAnalogPinNumber:
		argArray: 	#()
	Receiver's instance variables: 
a S4ACommandHandler

S4ACommandHandler>>handle:
	Receiver: a S4ACommandHandler
	Arguments and temporary variables: 
		aCommand: 	#(#activateAnalogPin)
		commandName: 	#activateAnalogPin
		arguments: 	#()
	Receiver's instance variables: 
a S4ACommandHandler

S4AWebSocketHandler>>handleMessage:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aMessage: 	'activateAnalogPin&'
		parsedMessage: 	#(#activateAnalogPin)
		response: 	nil
	Receiver's instance variables: 
a S4AWebSocketHandler

[:message | 
| response |
self debugLog: 'Received WebSocket message from Snap!: ' , message.
	response := self handleMessage: message.
	response
		ifNotNil: [aWebSocket sendText: response asString.
			self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]] in [aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aWebSocket: 	a ZnWebSocket(#server)
		message: 	'activateAnalogPin&'
		response: 	nil
	Receiver's instance variables: 
a S4AWebSocketHandler

ZnWebSocket>>runWith:
	Receiver: a ZnWebSocket(#server)
	Arguments and temporary variables: 
		block: 	[:message | 
| response |
self debugLog: 'Received WebSocket message fro...etc...
		message: 	'activateAnalogPin&'
	Receiver's instance variables: 
		stream: 	a ZdcSocketStream
		role: 	#server
		log: 	a ZnLogSupport


[aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aWebSocket: 	a ZnWebSocket(#server)
	Receiver's instance variables: 
a S4AWebSocketHandler

BlockClosure>>on:do:
	Receiver: [aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket ...etc...
	Arguments and temporary variables: 
		exception: 	ConnectionClosed
		handlerAction: 	[self debugLog: 'WebSocket connection closed']
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	S4AWebSocketHandler>>value:
		startpc: 	70
		numArgs: 	0


S4AWebSocketHandler>>value:
	Receiver: a S4AWebSocketHandler
	Arguments and temporary variables: 
		aWebSocket: 	a ZnWebSocket(#server)
	Receiver's instance variables: 
a S4AWebSocketHandler

[:webSocket | 
webSocket log: self log.
	self handler value: webSocket] in ZnWebSocketDelegate>>continuation
	Receiver: a ZnWebSocketDelegate
	Arguments and temporary variables: 
		webSocket: 	a ZnWebSocket(#server)
	Receiver's instance variables: 
		prefix: 	an OrderedCollection('s4a')
		handler: 	a S4AWebSocketHandler


ZnWebSocketResponse>>useConnection:
	Receiver: a ZnWebSocketResponse(101 Switching Protocols)
	Arguments and temporary variables: 
		connection: 	a ZdcSocketStream
		webSocket: 	a ZnWebSocket(#server)
		message: 	nil
	Receiver's instance variables: 
		headers: 	a ZnHeaders('Connection'->'Upgrade' 'Date'->'Fri, 17 Jan 2014 12:41:07...etc...
		entity: 	nil
		statusLine: 	a ZnStatusLine(101 Switching Protocols)
		continuation: 	[:webSocket | 
webSocket log: self log.
	self handler value: webS...etc...


ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		stream: 	a ZdcSocketStream
		request: 	a ZnRequest(GET /s4a)
		response: 	a ZnWebSocketResponse(101 Switching Protocols)
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[[self executeOneRequestResponseOn: stream] whileFalse.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		stream: 	a ZdcSocketStream
		request: 	nil
		response: 	nil
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[p psValueAt: index put: anObject.
	aBlock value] in ZnCurrentServer(DynamicVariable)>>value:during:
	Receiver: a ZnCurrentServer
	Arguments and temporary variables: 
		anObject: 	a ZnManagingMultiThreadedServer(running 4001)
		aBlock: 	[[self executeOneRequestResponseOn: stream] whileFalse.
	nil]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	5


BlockClosure>>ensure:
	Receiver: [p psValueAt: index put: anObject.
	aBlock value]
	Arguments and temporary variables: 
		aBlock: 	[p psValueAt: index put: oldValue]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnCurrentServer(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnCurrentServer(DynamicVariable)>>value:during:
	Receiver: a ZnCurrentServer
	Arguments and temporary variables: 
		anObject: 	a ZnManagingMultiThreadedServer(running 4001)
		aBlock: 	[[self executeOneRequestResponseOn: stream] whileFalse.
	nil]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	5


ZnCurrentServer class(DynamicVariable class)>>value:during:
	Receiver: ZnCurrentServer
	Arguments and temporary variables: 
		anObject: 	a ZnManagingMultiThreadedServer(running 4001)
		aBlock: 	[[self executeOneRequestResponseOn: stream] whileFalse.
	nil]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	132
		layout: 	nil
		instanceVariables: 	nil
		organization: 	a ClassOrganizer
		subclasses: 	nil
		name: 	#ZnCurrentServer
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	nil
		localSelectors: 	nil
		hash: 	nil
		soleInstance: 	a ZnCurrentServer


ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		stream: 	a ZdcSocketStream
		request: 	nil
		response: 	nil
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[self executeRequestResponseLoopOn: stream] in [[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		listeningSocket: 	a Socket[waitingForConnection]
		stream: 	a ZdcSocketStream
		socket: 	a Socket[connected]
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


BlockClosure>>ensure:
	Receiver: [self executeRequestResponseLoopOn: stream]
	Arguments and temporary variables: 
		aBlock: 	[self log debug: 'Closing stream'.
	self closeSocketStream: stream]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[[self executeRequestResponseLoopOn: stream]
		ensure: [self log ...etc...
		startpc: 	118
		numArgs: 	0


[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		listeningSocket: 	a Socket[waitingForConnection]
		stream: 	a ZdcSocketStream
		socket: 	a Socket[connected]
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


BlockClosure>>ifCurtailed:
	Receiver: [[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
...etc...
	Arguments and temporary variables: 
		aBlock: 	[self log debug: 'Destroying socket'.
	socket destroy]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	[[[self executeRequestResponseLoopOn: stream]
		ensure: [self log...etc...
		startpc: 	113
		numArgs: 	0


[[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
	Receiver: a ZnManagingMultiThreadedServer(running 4001)
	Arguments and temporary variables: 
		listeningSocket: 	a Socket[waitingForConnection]
		stream: 	a ZdcSocketStream
		socket: 	a Socket[connected]
	Receiver's instance variables: 
		options: 	a Dictionary(#delegate->a ZnWebSocketDelegate #port->4001 #reader->[:s...etc...
		sessionManager: 	nil
		process: 	a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore ...etc...
		serverSocket: 	a Socket[waitingForConnection]
		log: 	a ZnLogSupport
		lastRequest: 	nil
		lastResponse: 	nil
		lock: 	a Mutex
		connections: 	an OrderedCollection(a ZdcSocketStream)


[self value.
	Processor terminateActive] in BlockClosure>>newProcess
	Receiver: [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'....etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnec...etc...
		startpc: 	108
		numArgs: 	0



--- The full stack ---
S4ACommandHandler(Object)>>error:
S4ACommandHandler(Object)>>perform:withArguments:inSuperclass:
S4ACommandHandler(Object)>>perform:withArguments:
S4ACommandHandler>>handle:
S4AWebSocketHandler>>handleMessage:
[:message | 
| response |
self debugLog: 'Received WebSocket message from Snap!: ' , message.
	response := self handleMessage: message.
	response
		ifNotNil: [aWebSocket sendText: response asString.
			self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]] in [aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
ZnWebSocket>>runWith:
[aWebSocket
		runWith: [:message | 
			| response |
			self debugLog: 'Received WebSocket message from Snap!: ' , message.
			response := self handleMessage: message.
			response
				ifNotNil: [aWebSocket sendText: response asString.
					self debugLog: 'Sending WebSocket message to Snap!: ' , response printString]]] in S4AWebSocketHandler>>value:
BlockClosure>>on:do:
S4AWebSocketHandler>>value:
[:webSocket | 
webSocket log: self log.
	self handler value: webSocket] in ZnWebSocketDelegate>>continuation
ZnWebSocketResponse>>useConnection:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[[self executeOneRequestResponseOn: stream] whileFalse.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[p psValueAt: index put: anObject.
	aBlock value] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[self executeRequestResponseLoopOn: stream] in [[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]] in [[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[[[self executeRequestResponseLoopOn: stream]
		ensure: [self log debug: 'Closing stream'.
			self closeSocketStream: stream]]
		ifCurtailed: [self log debug: 'Destroying socket'.
			socket destroy]] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
BlockClosure>>ifCurtailed:
Delay>>wait
WorldState>>interCyclePause:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in MorphicUIManager>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self value.
	Processor terminateActive] in BlockClosure>>newProcess
  stack:

[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Delay class>>handleTimerEvent
  stack:

Delay class>>handleTimerEvent
Delay class>>runTimerEventLoop
[self runTimerEventLoop] in Delay class>>startTimerEventLoop
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[self eventLoop] in InputEventFetcher>>installEventLoop
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[self lowSpaceWatcher] in SmalltalkImage>>installLowSpaceWatcher
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in ProcessorScheduler class>>idleProcess
  stack:

ProcessorScheduler class>>idleProcess
[self idleProcess] in ProcessorScheduler class>>startUp
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [[event wait.
	processSynchronizationDelay wait.
	self changed: #childProcessStatus] repeat.
	nil] in UnixOSProcessAccessor>>grimReaperProcess
  stack:

[[event wait.
	processSynchronizationDelay wait.
	self changed: #childProcessStatus] repeat.
	nil] in UnixOSProcessAccessor>>grimReaperProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>waitForAcceptFor:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[[serverSocket isValid
		ifFalse: [^ self listenLoop].
	self serveConnectionsOn: serverSocket] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
BlockClosure>>ifCurtailed:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
[[self listenLoop] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>start
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>waitForAcceptFor:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[[serverSocket isValid
		ifFalse: [^ self listenLoop].
	self serveConnectionsOn: serverSocket] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
BlockClosure>>ifCurtailed:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>listenLoop
[[self listenLoop] repeat.
	nil] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>start
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForDataFor:ifClosed:ifTimedOut:
Socket>>waitForDataFor:
ZdcSocketStream(ZdcAbstractSocketStream)>>socketWaitForData
ZdcSocketStream(ZdcSimpleSocketStream)>>fillReadBuffer
ZdcSocketStream(ZdcAbstractSocketStream)>>next
ZnLineReader>>processNext
ZnLineReader>>nextLine
ZnRequestLine>>readFrom:
ZnRequestLine class>>readFrom:
ZnRequest>>readHeaderFrom:
ZnRequest(ZnMessage)>>readFrom:
ZnRequest class(ZnMessage class)>>readFrom:
[:stream | ZnRequest readFrom: stream] in [[:stream | ZnRequest readFrom: stream]] in ZnManagingMultiThreadedServer(ZnServer)>>reader
[self reader value: stream] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>readRequest:
[^ block value] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>withMaximumEntitySizeDo:
[p psValueAt: index put: anObject.
	aBlock value] in ZnMaximumEntitySize(DynamicVariable)>>value:during:
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForDataFor:ifClosed:ifTimedOut:
Socket>>waitForDataFor:
ZdcSocketStream(ZdcAbstractSocketStream)>>socketWaitForData
ZdcSocketStream(ZdcSimpleSocketStream)>>fillReadBuffer
ZdcSocketStream(ZdcAbstractSocketStream)>>next
ZnLineReader>>processNext
ZnLineReader>>nextLine
ZnRequestLine>>readFrom:
ZnRequestLine class>>readFrom:
ZnRequest>>readHeaderFrom:
ZnRequest(ZnMessage)>>readFrom:
ZnRequest class(ZnMessage class)>>readFrom:
[:stream | ZnRequest readFrom: stream] in [[:stream | ZnRequest readFrom: stream]] in ZnManagingMultiThreadedServer(ZnServer)>>reader
[self reader value: stream] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>readRequest:
[^ block value] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>withMaximumEntitySizeDo:
[p psValueAt: index put: anObject.
	aBlock value] in ZnMaximumEntitySize(DynamicVariable)>>value:during:
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForDataFor:ifClosed:ifTimedOut:
Socket>>waitForDataFor:
ZdcSocketStream(ZdcAbstractSocketStream)>>socketWaitForData
ZdcSocketStream(ZdcSimpleSocketStream)>>fillReadBuffer
ZdcSocketStream(ZdcAbstractSocketStream)>>next
ZnLineReader>>processNext
ZnLineReader>>nextLine
ZnRequestLine>>readFrom:
ZnRequestLine class>>readFrom:
ZnRequest>>readHeaderFrom:
ZnRequest(ZnMessage)>>readFrom:
ZnRequest class(ZnMessage class)>>readFrom:
[:stream | ZnRequest readFrom: stream] in [[:stream | ZnRequest readFrom: stream]] in ZnManagingMultiThreadedServer(ZnServer)>>reader
[self reader value: stream] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>readRequest:
[^ block value] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>withMaximumEntitySizeDo:
[p psValueAt: index put: anObject.
	aBlock value] in ZnMaximumEntitySize(DynamicVariable)>>value:during:
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForDataFor:ifClosed:ifTimedOut:
Socket>>waitForDataFor:
ZdcSocketStream(ZdcAbstractSocketStream)>>socketWaitForData
ZdcSocketStream(ZdcSimpleSocketStream)>>fillReadBuffer
ZdcSocketStream(ZdcAbstractSocketStream)>>next
ZnLineReader>>processNext
ZnLineReader>>nextLine
ZnRequestLine>>readFrom:
ZnRequestLine class>>readFrom:
ZnRequest>>readHeaderFrom:
ZnRequest(ZnMessage)>>readFrom:
ZnRequest class(ZnMessage class)>>readFrom:
[:stream | ZnRequest readFrom: stream] in [[:stream | ZnRequest readFrom: stream]] in ZnManagingMultiThreadedServer(ZnServer)>>reader
[self reader value: stream] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>readRequest:
[^ block value] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>withMaximumEntitySizeDo:
[p psValueAt: index put: anObject.
	aBlock value] in ZnMaximumEntitySize(DynamicVariable)>>value:during:
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForDataFor:ifClosed:ifTimedOut:
Socket>>waitForDataFor:
ZdcSocketStream(ZdcAbstractSocketStream)>>socketWaitForData
ZdcSocketStream(ZdcSimpleSocketStream)>>fillReadBuffer
ZdcSocketStream(ZdcAbstractSocketStream)>>next
ZnLineReader>>processNext
ZnLineReader>>nextLine
ZnRequestLine>>readFrom:
ZnRequestLine class>>readFrom:
ZnRequest>>readHeaderFrom:
ZnRequest(ZnMessage)>>readFrom:
ZnRequest class(ZnMessage class)>>readFrom:
[:stream | ZnRequest readFrom: stream] in [[:stream | ZnRequest readFrom: stream]] in ZnManagingMultiThreadedServer(ZnServer)>>reader
[self reader value: stream] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>readRequest:
[^ block value] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>withMaximumEntitySizeDo:
[p psValueAt: index put: anObject.
	aBlock value] in ZnMaximumEntitySize(DynamicVariable)>>value:during:
------------------------------

Process: a Process in [self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
  stack:

[self schedule.
	beingWaitedOn
		ifTrue: [delaySemaphore wait]
		ifFalse: [expired := true]] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
Socket>>waitForDataFor:ifClosed:ifTimedOut:
Socket>>waitForDataFor:
ZdcSocketStream(ZdcAbstractSocketStream)>>socketWaitForData
ZdcSocketStream(ZdcSimpleSocketStream)>>fillReadBuffer
ZdcSocketStream(ZdcAbstractSocketStream)>>next
ZnLineReader>>processNext
ZnLineReader>>nextLine
ZnRequestLine>>readFrom:
ZnRequestLine class>>readFrom:
ZnRequest>>readHeaderFrom:
ZnRequest(ZnMessage)>>readFrom:
ZnRequest class(ZnMessage class)>>readFrom:
[:stream | ZnRequest readFrom: stream] in [[:stream | ZnRequest readFrom: stream]] in ZnManagingMultiThreadedServer(ZnServer)>>reader
[self reader value: stream] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>readRequest:
[^ block value] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>withMaximumEntitySizeDo:
[p psValueAt: index put: anObject.
	aBlock value] in ZnMaximumEntitySize(DynamicVariable)>>value:during:
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
logger nextPutAll: 'Processes and their stacks: ';
		 cr.
	Process allInstances
		do: [:each | 
			| ctx |
			logger nextPutAll: 'Process: ';
				 print: each;
				 cr;
				 nextPutAll: '  stack:';
				 cr;
				 cr.
			ctx := each isActiveProcess
						ifTrue: [thisContext sender]
						ifFalse: [each suspendedContext].
			ctx
				ifNotNil: [(ctx stackOfSize: 20)
						do: [:s | logger print: s;
								 cr]].
			logger nextPutAll: '------------------------------';
				 cr;
				 cr]] in [Smalltalk logError: aString inContext: aContext.
	Smalltalk
		logDuring: [:logger | 
			logger nextPutAll: 'Processes and their stacks: ';
				 cr.
			Process allInstances
				do: [:each | 
					| ctx |
					logger nextPutAll: 'Process: ';
						 print: each;
						 cr;
						 nextPutAll: '  stack:';
						 cr;
						 cr.
					ctx := each isActiveProcess
								ifTrue: [thisContext sender]
								ifFalse: [each suspendedContext].
					ctx
						ifNotNil: [(ctx stackOfSize: 20)
								do: [:s | logger print: s;
										 cr]].
					logger nextPutAll: '------------------------------';
						 cr;
						 cr]]] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[logStream := self openLog.
	aMonadicBlock value: logStream] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[Smalltalk logError: aString inContext: aContext.
	Smalltalk
		logDuring: [:logger | 
			logger nextPutAll: 'Processes and their stacks: ';
				 cr.
			Process allInstances
				do: [:each | 
					| ctx |
					logger nextPutAll: 'Process: ';
						 print: each;
						 cr;
						 nextPutAll: '  stack:';
						 cr;
						 cr.
					ctx := each isActiveProcess
								ifTrue: [thisContext sender]
								ifFalse: [each suspendedContext].
					ctx
						ifNotNil: [(ctx stackOfSize: 20)
								do: [:s | logger print: s;
										 cr]].
					logger nextPutAll: '------------------------------';
						 cr;
						 cr]]] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
Error>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
Error(Exception)>>signal
Error(Exception)>>signal:
S4ACommandHandler(Object)>>error:
------------------------------

Process: a Process in [ScheduledDelay := self.
	TimingSemaphore signal] in Delay>>schedule
  stack:

[ScheduledDelay := self.
	TimingSemaphore signal] in Delay>>schedule
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
Delay>>schedule
Delay>>wait
[[self step.
	(Delay forMilliseconds: self stepTime) wait] repeat.
	nil] in Firmata>>startSteppingProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
BlockClosure>>ifCurtailed:
Delay>>wait
[[[self sendKeepAlive]
		on: Error
		do: [(Delay forMilliseconds: 100) wait.
			S4ArduinoManager singleton disconnect].
	(Delay forMilliseconds: self keepAliveTime) wait] repeat.
	nil] in Arduino>>startKeepAliveProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------

